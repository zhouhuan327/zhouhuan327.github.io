{"meta":{"title":"zhouH's Blog","subtitle":"","description":"","author":"zhou huan","url":"http://zhsblog.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-12-18T05:56:56.062Z","updated":"2021-12-18T05:56:56.062Z","comments":true,"path":"404.html","permalink":"http://zhsblog.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-12-18T05:56:56.064Z","updated":"2021-12-18T05:56:56.064Z","comments":true,"path":"about/index.html","permalink":"http://zhsblog.top/about/index.html","excerpt":"","text":"这个人很懒~"},{"title":"archives","date":"2019-12-19T07:41:17.000Z","updated":"2021-12-18T05:56:56.065Z","comments":true,"path":"archives/index.html","permalink":"http://zhsblog.top/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-12-18T05:56:56.065Z","updated":"2021-12-18T05:56:56.065Z","comments":true,"path":"categories/index.html","permalink":"http://zhsblog.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-12-18T05:56:56.065Z","updated":"2021-12-18T05:56:56.065Z","comments":true,"path":"friends/index.html","permalink":"http://zhsblog.top/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2021-12-18T05:56:56.065Z","updated":"2021-12-18T05:56:56.065Z","comments":true,"path":"tags/index.html","permalink":"http://zhsblog.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"手写Redux/React-Redux核心API","slug":"redux","date":"2021-12-18T04:50:15.000Z","updated":"2021-12-18T06:18:18.962Z","comments":true,"path":"2021/12/18/redux/","link":"","permalink":"http://zhsblog.top/2021/12/18/redux/","excerpt":"Redux/ReactRedux 手写","text":"Redux/ReactRedux 手写 前言这篇文章会带大家梳理一下React、React-Redux的原理，以及核心API的最简实现。适合已经使用过redux，但对原理不大了解的读者。 简介在开始之前先简单介绍一下这两个库,以及他们的区别 Redux Redux是一个Javascript状态管理库。他的做的事情非常简单: 使用一个对象去描述应用的状态state,并只能通过action配合reducer去修改state。同时提供了一个订阅服务,在状态被修改时会通知所有订阅者。 state tree 存放应用状态的状态树。 action 可以将它理解为改变状态的一个指令,通常是一个这样的对象&#123;type: &#39;ADD&#39;,payload: 1&#125;，type字段告诉reducer该怎么去改变store中的状态，payload则是携带的数据。 reducer 一个返回新状态的纯函数,它接收一个action,通过判断其中type字段对全局状态进行不同的操作,返回一个全新的状态树。 Redux核心部分仅负责状态维护和订阅通知, 是与框架完全无关的。 React-Redux React Redux 是 React 的官方 Redux UI 绑定库,帮助用户在组件中拿到Redux中存放的状态以及更新状态的操作。 实现Redux基本使用我们先通过这个DEMO看一下如何使用Redux 1234567891011121314151617181920212223242526272829import &#123; createStore &#125; from &#x27;redux&#x27;const preloadedState = &#123; count: 0,&#125;;// reducerconst reducer = (state, action) =&gt; &#123; switch (action.type) &#123; case &quot;INCREASE&quot;: return &#123; ...state, count: state.count + 1 &#125;; case &quot;DECREASE&quot;: return &#123; ...state, count: state.count - 1 &#125;; case &quot;SET_COUNT&quot;: return &#123; ...state, count: action.payload &#125;; default: return state; &#125;&#125;;// actionconst actions = &#123; increment: () =&gt; (&#123; type: &quot;INCREASE&quot; &#125;), decrement: () =&gt; (&#123; type: &quot;DECREASE&quot; &#125;), setCount: (count) =&gt; (&#123; type: &quot;SET_COUNT&quot;, payload: count &#125;),&#125;;const store = createStore(reducer, preloadedState);const state = store.getState() // 获取状态树store.subscribe(() =&gt; console.log(&#x27;store变啦&#x27;,store.getState())); // 订阅状态变化store.dispatch(actions.setCount(233)); // 触发状态变化store.dispatch(actions.increment()); // 触发状态变化 可以看到Redux包含了以下方法 createStore接收一个默认状态树和reducer函数并返回一个store,store中包含以下方法 store.getState 获取状态 store.dispatch 通过派发action去修改状态 store.subscribe 订阅状态的变化 createStoregetStategetState非常简单,我们返回函数中定义的state即可。 1234567function createStore(reducer, preloadedState) &#123; let state = preloadedState; // 定义初始的状态树 const getState = () =&gt; state; // 返回状态树 return &#123; getState &#125;;&#125; dispach这是一个修改状态的函数，通过前面的介绍我们知道state不应该被直接修改,而是每次需要更新时就通过action和reducer来获得一个新的state tree。 1const newState = reducer(oldState,action) 所以dispatch需要做的就是接收一个action,通过reducer生成新的state 并替换旧的 state 12345678910111213 function createStore(reducer, preloadedState) &#123; let state = preloadedState; // 定义初始的状态树 const getState = () =&gt; state; // 返回状态树 const dispatch = (action) =&gt; &#123; // 获得新的状态树 state = reducer(state, action); // 这里还需要通知所有订阅者 &#125;; return &#123; getState, dispatch &#125;;&#125; subscribe 我们已经实现的状态的创建、获取、修改,但都只是对闭包内变量的操作,外界并不能感知到。subscribe 需要提供一个通知外接订阅者状态更新了的这么一个功能。 这里我们可以通过实现一个简易的发布订阅模式来达到这个效果。在函数内部再维护一个listeners 数组，里面存放订阅者的回调函数。在每次状态变化（dispatch被调用）时，就执行所有回调。 1234567891011121314151617181920212223 function createStore(reducer, preloadedState) &#123; let state = preloadedState; // 定义初始的状态树 const getState = () =&gt; state; // 返回状态树 const listeners = []; // 订阅 const subscribe = (fn) =&gt; &#123; listeners.push(fn); // 取消订阅 return () =&gt; &#123; const index = listeners.find((item) =&gt; item === fn); listeners.splice(index, 1); &#125;; &#125;; const dispatch = (action) =&gt; &#123; // 获得新的状态树 state = reducer(state, action); // 通知所有订阅者 listeners.forEach((fn) =&gt; fn()); &#125;; return &#123; getState , dispatch, subscribe &#125;;&#125; 至此我们已经实现了一个乞丐版本的redux，我们来测试一下 123456789101112131415const preloadedState = &#123;/** ... */&#125;;const reducer = (state, action) =&gt; &#123;/** ... */&#125;;const actions = &#123;/** ... */&#125;;const store = createStore(reducer, preloadedState);console.log(&#x27;初始状态&#x27; , store.getState())const unsubscribe = store.subscribe( // 订阅 () =&gt; console.log(&#x27;我知道state变啦&#x27;,store.getState())); store.dispatch(actions.setCount(233)); store.dispatch(actions.increment());unsubscribe(); // 取消订阅store.dispatch(actions.increment()); // 这次更新不会通知到我 combineReducers随着应用变得越来越复杂，我们就可以考虑将 reducer 函数拆分成多个单独的函数，每个函数负责独立管理state的一部分。 Redux就有几个扩展api用来增强reducer和dispatch。combineReducers可以将多个reducer合并成一个最终的reducer函数。 applyMiddleware可以让我们自己包装 store 的 dispatch来增强功能，比如实现异步action。 这里只介绍combineReducers,该方法接收一个对象，通过为传入对象的reducer命名不同的 key 来控制返回 state key 的命名。 123456// 合并后的reducerconst rootReducer = combineReducers(&#123;potato: potatoReducer, tomato: tomatoReducer&#125;)// 相应的，state的结构就得是const rootState = &#123; potato: &#123;&#125;, tomato: &#123;&#125; &#125;const store = createStore(rootReducer, rootState) 实现思路就是通过传入对象的key去关联reducer和state中的部分状态，当接收到action时，需要执行所有reducer获得新的状态，然后将这些状态重新组装成一个新的状态树。 1234567891011121314151617181920export default function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers) // 返回合并后的reducer函数 return function combinedReducer(state = &#123;&#125;, action) &#123; // 新的state const nextState = &#123;&#125; // 遍历执行所有的reducers for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] // 代表state的key const reducer = reducers[key] // key对应的reducer // 当前key对应state的 旧值 const prevKeyState = state[key] // 执行reducer,获得当前key对应state的新值 const nextKeyState = reducer(prevKeyState, action) // 组装最终的state nextState[key] = nextKeyState &#125; return nextState &#125; &#125; 实现React-Redux基本使用和前面一样，我们先看个DEMO 12345678910111213141516171819202122232425262728293031323334import store from &#x27;./store&#x27;import &#123; Provider,connect &#125; from &#x27;react-redux&#x27;function App() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;Footer /&gt; &lt;/Provider&gt; )&#125;// 映射state到propsconst mapState = (state) =&gt; (&#123; count: state.count &#125;);// 映射dispatch到propsconst mapDispatch = (dispatch) =&gt; (&#123; increment: () =&gt; dispatch(&#123; type: &quot;increment&quot; &#125;),&#125;);const Header = connect(mapState)((props) =&gt; &#123; const &#123; count &#125; = props; return &lt;header&gt; header: &#123;count&#125;&lt;/header&gt;;&#125;);const Main = connect(mapState,mapDispatch)((props) =&gt; &#123; const &#123; count, increment &#125; = props; return ( &lt;main&gt; Main: count:&#123;count&#125; &lt;button onClick=&#123;increment&#125;&gt;increase &lt;/button&gt; &lt;/main&gt; );&#125;);function Footer(props) &#123; return &lt;footer&gt;footer 没用到状态&lt;/footer&gt;;&#125; 可以看到 react-redux 提供了一个Provider组件，用于将redux中创建的store透传给所有的子组件。 以及一个connect函数，它可以让被包裹的组件直接通过props访问store中那些被‘map’的状态和dispatch函数。这里的map可以理解为映射关系。 mapStateToProps函数可以让你控制store中哪些状态会被映射到组件的props中。 mapDispatchToProps让你可以自行封装dispatch函数并映射到props中。 默认情况下，如果都不传的话组件会拿到整个store和dispatch函数。 1connect(mapStateToProps, mapDispatchToProps)(MyComponent) Context使用React的createContext方法直接创建一个context即可 123import React from &#x27;react&#x27;const ReduxContext = React.createContext(null)export default ReduxContext ProviderProvider 接收store 并通过 ReduxContext 传给所有子组件 123456789101112import React from &#x27;react&#x27;import ReduxContext from &quot;./Context&quot;;const Provider = (props: any) =&gt; &#123; const &#123; store, children, ...rest &#125; = props; // 把store透传给所有子组件 return ( &lt;ReduxContext.Provider value=&#123;store&#125; &#123;...rest&#125;&gt; &#123;children&#125; &lt;/ReduxContext.Provider&gt; );&#125;;export default Provider; connect先通过connect的调用方式去推断一下connect函数的结构。 1connect(mapStateToProps, mapDispatchToProps)(MyComponent) 首先它接收mapStateToProps,mapDispatchToProps 这两个函数，并且又返回了一个函数,该函数接收一个组件，并且能让组件中的props获得参数。 12345function connect(mapStateToProps, mapDispatchToProps) &#123; return function wrapWithConnect(component) &#123; // 这里需要向组件的props中注入参数 &#125;;&#125; 那么怎么才能在wrapWithConnect函数中拿到store，并传给组件的props呢？ store是通过context透传的，而只有在组件中才能消费context,所以很明显需要通过高阶组件（HOC）来实现这个功能。 12345678910111213141516171819202122232425function connect(mapStateToProps?: any, mapDispatchToProps?: any) &#123; return function wrapWithConnect(component) &#123; // 包裹组件，主要为了获取组件上下文 const HOC = (props) =&gt; &#123; const &#123; dispatch, getState, subscribe &#125; = useContext(AppContext); const state = getState(); function childPropsSelector(state) &#123; // 注入到props中的状态 // 可能是整个store, 也可能是被mapState 返回的几个特定状态 const stateProps = mapStateToProps ? mapStateToProps(state) : state; // 注入到props中改变状态的函数 // 可以是原本的dispatch,也可以是mapDispatch 返回的特定更新状态的函数 const dispatchProps = mapDispatchToProps ? mapDispatchToProps(dispatch) : dispatch; return &#123; ...stateProps, ...dispatchProps, ...props &#125;; &#125; // 获得最终子组件的的props const actualChildProps = childPropsSelector(state); return React.createElement(component, actualChildProps, props.children); &#125;; return HOC; &#125;;&#125; 通过一层高阶组件的包裹，我们可以从context中拿到store的信息，并经过一顿处理传给被包裹的组件。 接下来我们需要实现组件的更新，在react中更新组件的方式是通过setState,每次传入一个新的值就能触发更新。 通过store提供的的subscribe方法，我们可以知道状态在什么时候被dispatch，被改变了。 12345678// 强制更新组件const [, forceUpdate] = useState(&#123;&#125;);useEffect(() =&gt; &#123; const unsubscribe = subscribe(() =&gt; &#123; forceUpdate(&#123;&#125;); &#125;); return unsubscribe;&#125;, []); 这里还需要做一个小优化。现在的代码即使dispatch后的状态没有改变，组件中也会收到通知并触发组件的render。 123456789101112131415// 记录上一次渲染时的stateconst preStateRef = useRef(&#123;&#125;);preStateRef.current = state// 订阅storeuseEffect(() =&gt; &#123;const unsubscribe = subscribe(() =&gt; &#123; // 对比新的state和旧的state const state = getState(); if (!isShadowEqual(preStateRef.current, state)) &#123; forceUpdate(&#123;&#125;); &#125;&#125;);return unsubscribe;&#125;, []); 通过一个ref去记录旧的state,并在每次render之前对新旧state做一次浅层次的对比，就可以减少不必要的重渲染。当然真正的场景下不会只有这么简单的判断，具体可以查看源码react-redux 源码 最终的实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import React, &#123; useContext, useEffect, useRef, useState &#125; from &quot;react&quot;;import ReduxContext from &quot;./Context&quot;;function connect(mapStateToProps, mapDispatchToProps) &#123; return function wrapWithConnect(component) &#123; const HOC = (props) =&gt; &#123; const &#123; dispatch, getState, subscribe &#125; = useContext(ReduxContext); const state = getState(); const [, forceUpdate] = useState(&#123;&#125;); function childPropsSelector(state) &#123; const stateProps = mapStateToProps ? mapStateToProps(state) : state; const dispatchProps = mapDispatchToProps ? mapDispatchToProps(dispatch) : dispatch; return &#123; ...stateProps, ...dispatchProps, ...props &#125;; &#125; // 最终子组件的props const actualChildProps = childPropsSelector(state); // 记录上一次渲染时的state const preStateRef = useRef(&#123;&#125;); preStateRef.current = state; // 订阅store useEffect(() =&gt; &#123; const unsubscribe = subscribe(() =&gt; &#123; // 对比新的state和旧的state const state = getState(); if (!isShadowEqual(preStateRef.current, state)) &#123; forceUpdate(&#123;&#125;); &#125; &#125;); return unsubscribe; &#125;, []); return React.createElement(component, actualChildProps, props.children); &#125;; return HOC; &#125;;&#125;function isShadowEqual(origin: any, next: any) &#123; if (Object.is(origin, next)) &#123; return true; &#125; if ( origin &amp;&amp; typeof origin === &quot;object&quot; &amp;&amp; next &amp;&amp; typeof next === &quot;object&quot; ) &#123; if ( [...Object.keys(origin), ...Object.keys(next)].every( (k) =&gt; origin[k] === next[k] &amp;&amp; origin.hasOwnProperty(k) &amp;&amp; next.hasOwnProperty(k) ) ) &#123; return true; &#125; &#125; return false;&#125;export default connect; Hooks API除了使用connect，React-Redux还支持使用hook的方式去访问store useStore 拿到store的对象 useSelector 使用选择器函数从state中提取数据 useDipatch 拿到dispatch函数12345678910111213import React from &quot;react&quot;;import &#123; useSelector, useStore, useDispatch &#125; from &quot;react-redux&quot;;const CounterComponent = () =&gt; &#123; const store = useStore() const count = useSelector((state) =&gt; state.counter); const dispatch = useDispatch() return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;inc&#x27;&#125;)&#125;&gt;increase&lt;/button&gt; &lt;/div&gt; );&#125;; 访问store需要拿到context,而这里的调用都不需要我们自己传入context，所以需要事先拿到到这个context对象。 1234567import React, &#123; useEffect, useState &#125; from &#x27;react&#x27;;import context from &#x27;./Context&#x27;function createSelectorHook(context) &#123; const useSelector = (selector) =&gt; &#123;&#125; return useSelector&#125;export default createSelectorHook(context); 拿到context之后，就可以通过React.useContext访问到store了,接下来处理方式就和connect类似 1234567891011121314151617181920212223import React, &#123; useEffect, useState &#125; from &#x27;react&#x27;;import context from &#x27;./Context&#x27;function createSelectorHook(context) &#123; const useReduxContext = () =&gt; React.useContext(context) const useSelector = (selector) =&gt; &#123; const &#123; getState,subscribe &#125; = useReduxContext() const state = getState() const selectedState = selector(state); // 强制更新组件 const [, forceUpdate] = useState(&#123;&#125;); // 订阅store useEffect(() =&gt; &#123; const unsubscribe = subscribe(() =&gt; &#123; // 这里省略的state的浅层对比 forceUpdate(&#123;&#125;); &#125;); return unsubscribe; &#125;, []); return selectedState; &#125; return useSelector&#125;export default createSelectorHook(context); 其他两个API也是类似的思路，这里不再赘述。hooks的方式更适在函数组件中使用，不需要事前给组件包一层，更加的方便。而connect更适合类组件，也可以通过@connect 装饰器简化这一层包裹的过程。 结语本文通过一些的代码示例，手写实现了React和React-Redux的一些常用函数，实现参考了源码但是简化了很多优化和错误判断的步骤，重点在于梳理出实现功能的大致思路。如有描述不正确的地方，欢迎大家指正！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://zhsblog.top/tags/React/"}]},{"title":"typescript in react hooks","slug":"typescript-in-react-hooks","date":"2021-03-30T01:55:31.000Z","updated":"2021-12-18T05:56:56.064Z","comments":true,"path":"2021/03/30/typescript-in-react-hooks/","link":"","permalink":"http://zhsblog.top/2021/03/30/typescript-in-react-hooks/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"React Hooks 学习笔记","slug":"ReactHooks-学习笔记","date":"2020-07-26T04:50:15.000Z","updated":"2021-12-18T05:56:56.063Z","comments":true,"path":"2020/07/26/ReactHooks-学习笔记/","link":"","permalink":"http://zhsblog.top/2020/07/26/ReactHooks-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"React Hooks动机 能优化类组件的一些问题 不同组件之间的状态逻辑难以复用 复杂组件变得难以理解 class带来的一些问题，比如this指向 使用Hook的注意事项 只在函数的顶层调用Hook函数，不要在循环，条件判断，嵌套函数中使用 不要在普通javascript函数中调用Hook，而是在React组件中 不要在 useMemo、useReducer 或 useEffect 的参数函数中调用。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://zhsblog.top/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://zhsblog.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"前端面试题","slug":"面试","date":"2020-07-26T04:50:15.000Z","updated":"2021-12-18T05:56:56.064Z","comments":true,"path":"2020/07/26/面试/","link":"","permalink":"http://zhsblog.top/2020/07/26/%E9%9D%A2%E8%AF%95/","excerpt":"之前准备面试的时候记录的一些常见面试题，后续继续补充","text":"之前准备面试的时候记录的一些常见面试题，后续继续补充 HTML如何理解 HTML 语义化正确的标签做正确的事情，比如标题用 H1-H5 标签，段落用 p 标签，主要内容用 main 标签。 html 语义化可以让页面的结构更清晰，增加可读性。 有利于 SEO（搜索引擎优化） 相关知识 语义化的标签包括：body,header,nav,aside,articel,section,footer header: 代表页眉，通常包含 h1-h6 元素或者 hgroup article: 代表文档，页面中的一个内容。article 内部可以嵌套 section，代表相关内容 用过哪些 HTML5 标签内容相关的 header，main，footer，article（定义独立于文档其他部分的内容），section（表示文档的一个组成部分） 文字相关的 data，time，mark 功能相关的 video，canvas，audio，svg 后续问题：canvas 是如何绘制的等等等。 canvas是一个可以用 js 来绘制图形的 HTML 元素。 使用方法 12345const canvas = document.getElementById(&quot;canvas&quot;); //获取这个元素的引用const ctx = canvas.getContext(&quot;2d&quot;); //调用getContext()方法获取元素的上下文ctx.fillStyle = &quot;green&quot;;ctx.fillRect(10, 10, 150, 100); video 用于在 HTML 或者 XHTML 文档中嵌入媒体播放器 controls 允许用户控制视频的播放 poster 设置封面 事件：click,pause,play,timeupdate 123456789101112&lt;!-- Simple video example --&gt;&lt;video controls src=&quot;videofile.ogg&quot; autoplay poster=&quot;posterimage.jpg&quot;&gt; 抱歉，您的浏览器不支持内嵌视频，不过不用担心，你可以 &lt;a href=&quot;videofile.ogg&quot;&gt;下载&lt;/a&gt; 并用你喜欢的播放器观看!&lt;/video&gt;&lt;!-- Video with subtitles --&gt;&lt;video src=&quot;foo.ogg&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;foo.en.vtt&quot; srclang=&quot;en&quot; label=&quot;English&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;foo.sv.vtt&quot; srclang=&quot;sv&quot; label=&quot;Svenska&quot;&gt; &lt;!-- 字幕 --!&gt;&lt;/video&gt; HTML5 标签列表 严格模式与混杂模式 Doctype 作用是什么 !DOCTYPE 声明叫做文件类型定义（DTD），声明的作用为了告诉浏览器该用什么文档类型的规范来解析这个文档 严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。 混杂模式：又称怪异模式或兼容模式，是一种向后兼容的解析方法 HTML5 没有严格和混杂之分 meta viewportmeta viewport 是用来做移动端适配的,name 为 viewport 表示供移动设备使用. content 定义了 viewport 的属性. viewport就是设备的屏幕上能用来显示网页的那一块区域 属性名 说明 width 设置 layout viewport 的宽度，为一个正整数，或字符串 width-device initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes 代表允许 常用写法 123456&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;/&gt; https://segmentfault.com/a/1190000020218602 CSS什么是响应式设计？响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。 基本原理是通过媒体查询（@media）查询检测不同的设备屏幕尺寸做处理。 关于兼容： 页面头部必须有 mate 声明的viewport。 123456&lt;meta name=&quot;’viewport’&quot; content=&quot;”width=device-width,&quot; initial-scale=&quot;1.&quot; maximum-scale=&quot;1,user-scalable=no”&quot;/&gt; CSS3 有哪些新特性？关于CSS新增的特性，有以下： 选择器; 圆角（border-raduis）; 阴影（shadow）和反射（reflect）; 文字特效（text-shadow）; 文字渲染（text-decoration）; 线性渐变（gradient）; 旋转（rotate）/缩放（scale）/倾斜（skew）/移动（translate）; 媒体查询（@media）; RGBA和透明度 ; @font-face属性; 多背景图 ; 盒子大小; 语音; 两种盒模型早期 IE 的 border-box（怪异盒模型），W3C 的 content-box（标准盒模型） content-box width = 内容的宽度 height = 内容的高度 border-box width = border+padding+内容的宽度 height = border+padding+内容的高度 使用box-sizing来设置两种盒模型 后续问题：哪种更好，为什么？ border-box 更好，因为 border-box 计算了元素的边框，使得不会和其他元素重叠，写起来更方便 【关键词】那一种写起来更方便 BFC 是什么 块格式化上下文（Block Formatting Context，BFC）,是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域 BFC 是规定内部块级元素摆放规则的一个独立环境 块级盒子按照垂直方向，一个接一个的放置 块级盒子的垂直方向边距由上下 margin 决定，属于同一个 BFC 的两个相邻 Box 的上下 margin 会发生重叠 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 计算 BFC 的高度时，浮动元素也参与计算 如何创建 BFC 根元素（html 标签）或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） overflow 值不为 visible 的块元素 display 的值为 inline-block、table-cell、table-caption display 为flow-root(CSS3 新增) 应用场景 举几个含有 BFC 的例子 解决高度坍塌 浮动的元素会导致父元素高度坍塌，在父元素上加上 overflow:hidden，触发 BFC 重新计算元素尺寸。 解决 margin 重叠(同一个 BFC 中，相邻块级盒的竖直 margin 会合并) 在其中一个元素外面包一层容器，并触发容器生成 BFC。那么两个重叠的元素不属于同一个 BFC，就不会发生 margin 重叠 float+div 左右自适应布局 侧边栏 float:left 右边 overflow：auto ，都触发了 bfc 清除浮动123456789.clearfix &#123; zoom: 1； //ie兼容;&#125;.clearfix::after &#123; content: &quot;&quot;; display: block; clear: both;&#125; 或者创建 bfc CSS 选择器有哪些选择器？ ID 选择器（#myId） 类选择器（.myClass） 标签选择器（p,div） 相邻选择器（div+p） 子选择器（div&gt;p） 后代选择器（div p） 属性选择器（button[disabled=”true”]） 伪类选择器（a:hover） 伪元素选择器(div::before,div::after) !important &gt; style(内联) &gt; ID &gt; 类选择器/属性选择器/伪类 &gt; 标签选择器/伪元素 同权重情况下： 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中） 样式的继承可继承的样式：font-size,font-family,font-weight，color，visibility， 不可继承的样式：display,border,padding,margin,width,height 等等 flex如何实现垂直居中123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;一串文字&lt;/div&gt;&lt;/div&gt; 123456789.parent &#123; border: 1px solid red; width: 300px; height: 300px;&#125;.child &#123; width: 100px; height: 100px;&#125; 元素宽高固定 绝对定位+负 margin 12345678910.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; margin-left: -50px; //自身宽度的一半 margin-top: -50px; //自身高度的一半&#125; 绝对定位+margin auto 1234567891011.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;&#125; 元素不定宽高 绝对定位+transform 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; lineheight 123456789.parent &#123; height: 300px; line-height: 300px;&#125;.child &#123; display: inline-block; vertical-align: middle; line-height: initial;&#125; table-cell 12345678.parent &#123; display: table-cell; text-align: center; vertical-align: middle;&#125;.child &#123; display: inline-block;&#125; flex 1234.parent &#123; display: flex; align-items: center;&#125; 如何实现两栏布局1234&lt;section&gt; &lt;aside&gt;aside&lt;/aside&gt; &lt;main&gt;main&lt;/main&gt;&lt;/section&gt; flex 布局 父容器设置display:flex，定宽的一栏设置 flex-basic 或者 width，自适应的那一栏设置flex:1 或者flex-grow:1 1234567891011section &#123; display: flex;&#125;aside &#123; width: 200px;&#125;main &#123; flex-grow: 1; /* 控制展示的顺序*/ order: 1;&#125; grid 布局 123456789101112131415section &#123; display: gird; /* 格子是两列，第一列宽度200px ,第二列撑满剩余空间 */ grid-template-columns: 200px 1fr; grid-template-rows: auto;&#125;aside &#123; /* 放在第一和第二根线之间*/ grid-column: 1/2; grid-row: 1/2;&#125;main &#123; grid-column: 2/3; grid-row: 1/2;&#125; 传统浮动布局 a. 定宽的一栏设置左/右浮动，自适应的一栏设置左/右 margin 预留空间。同时为了防止父元素高度坍塌，还要清浮动。 b. 圣杯布局/双飞翼布局，主要利用的浮动和负 margin 的特性 什么是回流（重排）和重绘以及其区别？回流（重排）reflow:当render tree中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变时而需要重新构建； 重绘repaint:当render tree中的一些元素需要更新属性，而这些属性只影响元素的外观，风格，而不会影响布局时，称其为重绘，例如颜色改变等。 JS*跨域出于安全原因，浏览器会限制从脚本内发起的跨域HTTP 请求 只要协议、域名、端口有任何一个不同，都被当作是不同的域 JSONP 跨域 通过 script 标签引入的 js 是不受同源策略的限制的（jsonp 只能实现 get 请求） 12345678910//原生的实现方式let script = document.createElement(&quot;script&quot;);script.src = &quot;http://www.xxx.cn/login?username=zh&amp;callback=callback&quot;;document.body.appendChild(script);function callback(res) &#123; console.log(res);&#125; CORS CORS 是一个 W3C 标准，全称是”跨域资源共享“（Cross-origin resource sharing）。 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 简单请求： 请求方法是以下三种方法之一：HEAD,GET,POST http 头信息不超出一下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain) 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源不在许可范围内服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: &#x27;origin中指定的源（协议 + 域名 + 端口）&#x27;Access-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT 或 DELETE，或者 Content-Type 字段的类型是application/json 非简单请求会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 如果服务器否定了”预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求 通过反向代理跨域 跨域是浏览器禁止的，服务端并不禁止跨域 所以浏览器可以发给自己的服务端然后，由自己的服务端再转发给要跨域的服务端，做一层代理vue-cli的proxyTable用的是http-proxy-middleware中间件create-react-app用的是webpack-dev-server内部也是用的http-proxy-middlewarehttp-proxy-middleware内部用的http-proxy nginx 只需要在 Nginx 的配置文件中配置以下参数： 123456789location / &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;; add_header Access-Control-Allow-Headers &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;; if ($request_method = &#x27;OPTIONS&#x27;) &#123; return 204; &#125;&#125; *ES6 语法常用的：let const,箭头函数,解构,Promise，async await, class, es module,proxy 箭头函数与普通函数区别？1、没有自己的 this，arguments，super 或 new.target 2、.call()/.apply()/.bind()无法改变箭头函数中 this 的指向 3、箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数 4、箭头函数没有 prototype 5、箭头函数不能用作 Generator 函数，不能使用 yeild 关键字 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this *this 指向问题 fn this -&gt; window/global obj.fn() this -&gt; obj fn.call(xxx)/fn.apply(xxx)/fn.bind(xxx) this -&gt; xx new Fn() this -&gt; 新的对象 fn = ()=&gt;{} this -&gt; 外面的 this 12345func(p1, p2) 等价于func.call(undefined, p1, p2)obj.child.method(p1, p2) 等价于obj.child.method.call(obj.child, p1, p2) 如果 call 中传的 context 是 null 或 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined） [ ] 中的 this 12345678function fn ()&#123; console.log(this) &#125;var arr = [fn, fn2]arr[0]() // 这里面的 this 又是什么呢？ arr[0]()假想为 arr.0()然后转换为 arr.0.call(arr)那么里面的 this 就是 arr 了 :) Event Handler 中的 this 12345btn.addEventListener(&quot;click&quot;, function handler() &#123; console.log(this); // 请问这里的 this 是什么&#125;);//通常来说this的值是触发事件的元素的引用,当使用 addEventListener() 为一个元素注册事件的时候，句柄里的 this 值是该元素的引用。其与传递给句柄的 event 参数的 currentTarget 属性的值一样 什么是闭包/立即执行函数 红宝书(p178)上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数 闭包允许函数访问函数外部的变量。只要变量或函数存在于声明函数时所在的作用域内 闭包的作用： 可以访问函数外部的变量 让这些变量始终保存在内存中,不会再函数调用结束后被垃圾回收机制回收 实现私有变量 闭包产生的原因？ 作用域链 当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量。 每一个子函数都会拷贝上级的作用域，形成一个作用域的链条 闭包的表现形式 函数内返回一个函数 函数作为参数传递（比如回调函数） 原型链介绍 PromisePromise 是异步编程的一种解决方案,可以解决回调地狱问题。 promise 的三种状态 pending 初始状态 fulfilled 操作完成完成 rejected 操作失败 API Promise.resolve 返回一个给定值解析后的 Promise 对象 。 如果这个值是 promise，那么返回这个 promise 如果是 thenable（带有 then 方法），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态 其他情况以该值为成功状态返回一个 Promise 对象。 Promise.reject 类似 Promise.all 如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果。 如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。 Promise.race 多个 Promise 任务同时执行，返回最先执行结束的 Promise 任务的结果，不管这个 Promise 结果是成功还是失败。 怎么取消一个 Promise? Promise.race 1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;ok1&quot;);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;ok2&quot;); &#125;, 10);&#125;);Promise.race([p2, p1]) .then((result) =&gt; &#123; console.log(result); //ok1 &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;); 返回“pending”状态的 Promise 对象 123456789101112Promise.resolve() .then(() =&gt; &#123; console.log(&quot;ok1&quot;); return new Promise(() =&gt; &#123;&#125;); // 返回“pending”状态的Promise对象 &#125;) .then(() =&gt; &#123; // 后续的函数不会被调用 console.log(&quot;ok2&quot;); &#125;) .catch((err) =&gt; &#123; console.log(&quot;err-&gt;&quot;, err); &#125;); 深拷贝1、递归 2、判断类型，不同的类型要有不同的拷贝方法 3、检查循环引用 使用一个WeakMap结构存储已经被拷贝的对象，每一次进行拷贝的时候就先向WeakMap查询该对象是否已经被拷贝，如果已经被拷贝则取出该对象并返回 4、不可能拷贝** proto** 不用 class 如何实现继承？寄生组合继承 1234567891011121314151617181920212223function Animal(name) &#123; //属性 this.name = name; //实例方法 this.sleep = function () &#123; console.log(&quot;正在睡觉&quot;); &#125;;&#125;//原型方法Animal.prototype.eat = function () &#123; console.log(&quot;正在吃东西&quot;);&#125;;function Cat(name) &#123; Animal.apply(this); this.name = name;&#125;// 原型的继承let f = function () &#123;&#125;;f.prototype = Animal.prototype;Cat.prototype = new f();Cat.prototype.constructor = Cat; 用 class 实现的继承 12345class Cat extends Animal &#123; constructor() &#123; super(); &#125;&#125; 数组去重1、使用 hash 1234567891011function uniq(arr) &#123; let temp = &#123;&#125;, res = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!temp[arr[i]]) &#123; temp[arr[i]] = true; res.push(arr[i]); &#125; &#125; return res;&#125; 2、Set 1let arr = [...new Set(array)]; 3、Map 1234function uniq(arr) &#123; const res = new Map(); return arr.filter((a) =&gt; !res.has(a) &amp;&amp; res.set(a, 1));&#125; 数组扁平化1234567891011function flatten(arr) &#123; let res = []; arr.forEach((item) =&gt; &#123; if (Array.isArray(item)) &#123; res = res.concat(flatten(item)); &#125; else &#123; res.push(item); &#125; &#125;); return res;&#125; 123456function flatten(arr) &#123; while (arr.some((item) =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; a==1&amp;&amp;a==2&amp;&amp;a==31234const a = &#123; value: 0 &#125;;a.valueOf = function () &#123; return (this.value += 1);&#125;; (a === 1 &amp;&amp; a === 2 &amp;&amp; a ===3)的值也能是 true 吗？ 123456var value = 0; //window.valueObject.defineProperty(window, &quot;a&quot;, &#123; get: function () &#123; return (this.value += 1); &#125;,&#125;); 用正则实现 trim123function trim(string) &#123; return string.replace(/^\\s+|\\s+$/g, &quot;&quot;);&#125; Webpack有哪些常见的 loader 和 pluginLoader html html-loader ,file-loader(对 html 动态取名),extract-loader(html 和 bundle.js 进行区分) css style-loader , css-loader,scss-loader,less-loader js babel-loader,eslint-loader 图片 image-loader（加载并且压缩图片文件） Plugin html-webpack-plugin uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 happypack(使用多线程) loader 和 plugin 的区别 loader 直译为”加载器”。Loader 的作用是让 webpack 拥有了加载和解析非 js 文件的能力 plugin 直译为”插件”。是用于扩展 webpack 的功能的 Loader 在 module.rules 中配置 Plugin 在 plugin 中单独配置 如何按需加载代码import(‘file’).then() 如何提高构建速度happypack(使用多线程) webpack-uglifyjs-parallel 来进行代码压缩，并开启多线程 DLL 预编译资源模块，通过 DLLPlugin 来对那些我们引用但不会修改的 npm 包来进行预编译 打包后文件过大怎么办 压缩 js，css ，图片文件 使用 CommonsChunkPlugin 提取通用模块文件 使用 import（）按需加载 使用 CDN 加速。 Vue*Watch 和 compute 的区别watch 是监听一个值的变化，compute 是计算属性。 compute 的值在执行后是会缓存的，只有在他依赖的值发生改变后才会重新求值。 watch 在每次监听值的变化是，都会执行回调函数。 *有哪些生命周期钩子函数？分别有什么用？8 种 beforeCreate 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 Created 在实例创建完成后被立即调用。实例已完成数据观测，watch/event 的回调，但是挂载还没开始，$el 上不可用 beforeMount 在挂载之前调用 Mounted 在挂载完成之后调用。注意：不会保证所有的子组件也都一起被挂载 beforeUpdated Updated beforeDestory 实例销毁前被调用。在这一步，实例仍然可用。 Destroyed 实例销毁后调用。该钩子被调用后，所以子实例也被销毁，事件监听被移除，指令被解绑。 一般在 mounted 周期内进行数据请求，因为这个周期开始组件已经被挂载到真实的元素上。 *组件通信 父子组件: 触发 $emit(‘event name’,data) 监听 $on(‘event name’,function(){}) 爷孙组件/兄弟组件 eventBus Vuex Vue 的数据响应式vue 的响应式主要通过数据劫持。vue 通过 Object.defineProperty 的 getter/setter 对目标进行监听,在属性被访问和修改时通知变化,进而更新视图数据 缺点： 不能检测到对象属性的添加或删除 Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时 ，例如：vm.items.length = newLength 不能检测到数据的新增（但是可以使用 Vue.set ） Vue-routervue-router 有哪几种守卫？ 全局前置 beforeEach 全局后置 afterEach 路由独享钩子 beforEnter 守卫一般来做登录验证 vue-router 的两种模式 hash 原理是 onhashchage 事件，可以在 window 对象上监听这个事件 history 利用了 HTML5 History Interface 中新增的 pushState()和 replaceState()方法。 需要后台配置支持。如果刷新时，服务器没有响应响应的资源，会刷出 404 VuexVuex 是一个 vue 的状态管理工具，它采用集中式存储管理应用的所有组件的状态。 有五个核心概念：state,getter,mutation,action,module 什么时候用 vuex？ 当项目遇到以下两种场景时 多个组件依赖于同一状态时。 来自不同组件的行为需要变更同一状态。 虚拟 dom 虚拟 dom 是什么？ 虚拟 dom 是一个能代表 DOM 树的对象，通常包含标签名，属性，事件和子元素 虚拟 dom 的优点 能减少不必要的 dom 操作 能跨平台渲染（虚拟 dom 就是一个 js 对象，可以变成 dom 和可以变成小程序里的元素等） 虚拟 dom 的缺点 需要额外的创建函数，如 createElement 和 h 需要额外的构建过程，比如需要 jsx 需要 babel，vue 需要 vue-loader 规模较小的时候，虚拟 dom 更快 代码*Ajax1234567891011121314151617const xhr = new XMLHttpRequest();xhr.open(&quot;get&quot;, &quot;url&quot;);xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; // HTTP 状态在 200-300 之间表示请求成功 // HTTP 状态为 304 表示请求内容未发生改变，可直接从缓存中读取 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; &#125;&#125;;// xhr.readyStatus==0 尚未调用 open 方法// xhr.readyStatus==1 已调用 open 但还未发送请求（未调用 send）// xhr.readyStatus==2 已发送请求（已调用 send）// xhr.readyStatus==3 已接收到请求返回的数据// xhr.readyStatus==4 请求已完成xhr.send(null); *Promise*Promise.all1234567891011121314151617181920function promiseAll(list) &#123; return new Promise((resolve, reject) =&gt; &#123; if (!Array.isArray(list)) &#123; reject(&quot;arguments must be array&quot;); &#125; let count = 0; let res = []; list.forEach((p) =&gt; &#123; Promise.resolve(p) .then((value) =&gt; &#123; res.push(value); count++; if (count === list.length) &#123; resolve(res); &#125; &#125;) .catch((error) =&gt; reject(error)); &#125;); &#125;);&#125; instanceOf1234567891011121314function myinstanceof(left, right) &#123; let prototype = right.prototype; left = left.__proto__; while (true) &#123; if (left === null || left === undefined) &#123; return false; &#125; if (left === prototype) &#123; return true; &#125; left = left.__proto__; &#125;&#125;console.log(myinstanceof([], Array)); 事件委托简易版本 12345ul.addEventListener(&quot;click&quot;, function (e) &#123; if (e.target.tagName.toLowerCase() === &quot;li&quot;) &#123; console.log(&quot;点击了li&quot;); &#125;&#125;); 完整 123456789101112131415161718192021222324252627282930ul.addEventListener(&quot;click&quot;, function (e) &#123; let el = e.target; while (!el.matches(&quot;li&quot;)) &#123; if (&quot;ul&quot; === el) &#123; el = null; break; &#125; el = el.parentNode; &#125; if (el) &#123; console.log(&quot;点击了li&quot;); &#125;&#125;);//封装成函数function on(element, eventType, selector, fn) &#123; element.addEventListener(eventType, (e) =&gt; &#123; let el = e.target; while (!el.matches(selector)) &#123; if (element === el) &#123; el = null; break; &#125; el = el.parentNode; &#125; el &amp;&amp; fn.call(el, e, el); &#125;); return element;&#125; 拖拽 div12345678910111213141516171819202122232425const box = document.querySelector(&quot;.drag-box&quot;);let dragging = false;let position = null;box.addEventListener(&quot;mousedown&quot;, function (e) &#123; dragging = true; position = [e.clientX, e.clientY];&#125;);document.addEventListener(&quot;mousemove&quot;, function (e) &#123; if (dragging === false) &#123; return; &#125; const deltaX = e.clientX - position[0]; const deltaY = e.clientY - position[1]; const left = parseInt(box.style.left) || 0; const top = parseInt(box.style.top) || 0; box.style.left = left + deltaX + &quot;px&quot;; box.style.top = top + deltaY + &quot;px&quot;; position = [e.clientX, e.clientY];&#125;);document.addEventListener(&quot;mouseup&quot;, function (e) &#123; dragging = false;&#125;); compose,curry1234567891011121314151617181920212223242526272829303132333435function compose(...funcs) &#123; return function (x) &#123; return funcs.reduce((acc, fn) =&gt; &#123; return fn(acc); &#125;, x); &#125;;&#125;// const compose = (...funcs) =&gt; (x) =&gt; funcs.reduce((acc, fn) =&gt; fn(acc), x);function upperCase(input) &#123; return input &amp;&amp; typeof input === &quot;string&quot; ? input.toUpperCase() : input;&#125;function trim(input) &#123; return typeof input === &quot;string&quot; ? input.trim() : input;&#125;const composedFunc = compose(trim, upperCase);// 当柯里化后的函数接收到足够的参数后，就会开始执行原函数。//而如果接收到的参数不足的话，就会返回一个新的函数，用来接收余下的参数function curry(func) &#123; return function curried(...args) &#123; if (args.length &gt;= func.length) &#123; return func.apply(this, args); &#125; else &#123; return function (...args2) &#123; return curried.apply(this, args.concat(args2)); &#125;; &#125; &#125;;&#125;const add = (a, b) =&gt; a + b;const curriedAdd = curry(add);console.log(curriedAdd(1));console.log(curriedAdd(1)(2)); apply,call12345678910111213141516171819202122Function.prototype.myApply = function (...args) &#123; if (typeof this !== &quot;function&quot;) &#123; throw new TypeError(&quot;Error&quot;); &#125; let [context, params] = args; context = context || window; context.fn = this; const result = params ? context.fn(...params) : context.fn(); delete context.fn; return result;&#125;;Function.prototype.myCall = function (...args) &#123; if (typeof this !== &quot;function&quot;) &#123; throw new TypeError(&quot;Error&quot;); &#125; let [context, ...params] = args; context = context || window; context.fn = this; const result = context.fn(...params); delete context.fn; return result;&#125;; 深拷贝12345678910111213141516171819202122232425262728293031function deepClone(target, cache = new Map()) &#123; if (!(target instanceof Object)) &#123; return target; &#125; if (cache.has(target)) &#123; return target; &#125; // 判断四种特殊情况 const l = () =&gt; &#123;&#125;; let dist; if (target instanceof Array) &#123; dist = []; &#125; else if (target instanceof Function) &#123; dist = function () &#123; return target.call(this, ...arguments); &#125;; &#125; else if (target instanceof Date) &#123; dist = new Date(target); &#125; else if (target instanceof RegExp) &#123; dist = new RegExp(target.source, target.flags); &#125; else &#123; dist = &#123;&#125;; &#125; cache.set(dist, target); for (let key in target) &#123; if (target.hasOwnProperty(key)) &#123; dist[key] = deepClone(target[key], cache); &#125; &#125; return dist;&#125; 防抖节流函数防抖：将几次操作合并为一此操作进行 应用：联想输入框 123456789function debounce(fn, delay) &#123; let timeout = null; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.call(this); &#125;, delay); &#125;;&#125; 函数节流：使得一定时间内只触发一次函数 应用： 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。 用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。 1234567891011function throttle(fn, delay) &#123; let timeout = null return function () &#123; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; fn.call(this); timeout = null; &#125;, delay); &#125; &#125;; &#125; js 和 css 动画区别 chrome tab 进程 chrome 相同域名 一般公用一个进程 tree shaking 原理 代码分割 code split 权限控制从 大中小 三个方面来看 页面级别 菜单级别 按钮级别","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://zhsblog.top/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"【踩坑总结】Electron中开发子进程时遇到的问题","slug":"electron-problem","date":"2020-05-07T14:45:38.000Z","updated":"2021-12-18T05:56:56.063Z","comments":true,"path":"2020/05/07/electron-problem/","link":"","permalink":"http://zhsblog.top/2020/05/07/electron-problem/","excerpt":"问题：在开发过程中，创建了一个子进来程执行 cmd 的命令。在开发环境中没有任何问题，但是在打包后发现子进程并没有执行。","text":"问题：在开发过程中，创建了一个子进来程执行 cmd 的命令。在开发环境中没有任何问题，但是在打包后发现子进程并没有执行。 参考资料: https://segmentfault.com/a/1190000019981621?utm_source=tag-newest 1.子进程中用到的引用的外部资源需要在 pacage.json 中配置，比如我将一个 jar 文件放在了 api 文件夹中。 首先需要在 asarUnpack 中配置子进程中用到的第三方包 extraResources 用来配置资源文件的映射。匹配的路径会直接映射到对应的资源的路径（Contents/Resources for MacOS, resources for Linux and Windows） 123456789101112&quot;build&quot;: &#123; &quot;asarUnpack&quot;: [ &quot;**/api/**/*&quot; ], &quot;extraResources&quot;: [ &#123; &quot;from&quot;: &quot;api&quot;, &quot;to&quot;: &quot;app.asar.unpacked/api&quot; &#125; ], &#125;, 子进程中的路径问题 electron 中开发和打包后子进程的 fork 路径并不相同。在开发环境中可以使用相对路径，但是打包后不行。 路径需要做如下配置。 process.resoucesPath: electron 中定义的资源目录的路径，在打包后子进程 js 所在的路径 1234const path = isDev ? path.join(__dirname, &#x27;api&#x27;) : path.join(process.resourcesPath, &#x27;app.asar.unpacked/api&#x27;);const exec = require(&#x27;child_process&#x27;).exec;let cmdStr = &#x27;java -jar deliveryroute.jar&#x27;;let workerProcess = exec(cmdStr, &#123; cwd: path &#125;);","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"http://zhsblog.top/tags/electron/"}]},{"title":"centos7下各种环境的安装","slug":"centos7-develop-config","date":"2019-12-21T04:15:39.000Z","updated":"2021-12-18T05:56:56.063Z","comments":true,"path":"2019/12/21/centos7-develop-config/","link":"","permalink":"http://zhsblog.top/2019/12/21/centos7-develop-config/","excerpt":"最近我的云服务器又又又崩了，又得重新整一遍😭 记录一下常用工具的配置吧","text":"最近我的云服务器又又又崩了，又得重新整一遍😭 记录一下常用工具的配置吧 第一步，换源最好先换源，因为官方源在国外，会很慢。 1234567891011121314151617181920进入yum源配置文件所在的文件夹cd &#x2F;etc&#x2F;yum.repos.d&#x2F;备份本地yum源mv CentOS-Base.repo CentOS-Base.repo_bak获取国内yum源（阿里、163二选一）wget -O CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repowget -O CentOS-Base.repo http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS7-Base-163.repo清理yum缓存 yum clean all重建缓存 yum makecache 更新yum -y update 然后就可以快乐的搭建环境了 JAVA首先查询是否安装了JDK 12345678910#直接运行java命令，会提示命令未找到，则是没有安装过java环境java-bash: java: command not found或者yum list installed |grep java#卸载安装的 jdkyum -y remove java* 查看yum库中的Java安装包 1yum list java* 以yum库中java-1.8.0为例, “*”表示将java-1.8.0的所有相关Java程序都安装上 1yum -y install java-1.8.0-openjdk* 查看版本，检测是否安装成功 1java -version nodejs更新node.js各版本yum源 1234567891011#Node.js v8.xcurl --silent --location https://rpm.nodesource.com/setup_8.x | bash -#Node.js v7.xcurl --silent --location https://rpm.nodesource.com/setup_7.x | bash -#Node.js v6.xcurl --silent --location https://rpm.nodesource.com/setup_6.x | bash - 使用yum安装nodejs 1yum install -y nodejs 查看nodejs和npm版本 123node -v npm -v 使用npm安装node版本管理器 ‘ n ‘ 1npm install -g n 版本管理 1234567891011121314#查看所有版本n list#安装指定版本n &lt;version&gt;#安装最新版本n latest#安装稳定版本n stable #删除某个版本n rm &lt;version&gt; 服务器管理模块forever安装forever 1sudo npm install forever -g 启动进程 1forever start app.js 关闭进程 1234567forever stop app.jsforever stopall#forever list 找到对应的id，然后：forever stop [id] 输出日至 1forever start -l forever.log -o out.log -e err.log .&#x2F;var&#x2F;www 显示所有运行的服务 1forever list 具体命令参数可以通过 forever –help 查看。 或者 服务器管理模块forever MYSQL5.7检查系统中是否已安装 MySQL 1rpm -qa | grep mysql 没反应的话就说明没有安装。 注意：在新版本的CentOS7中，默认的数据库已更新为了Mariadb，而非 MySQL，所以执行 yum install mysql 命令只是更新Mariadb数据库，并不会安装 MySQL 。 查看已安装的 Mariadb 数据库版本 1rpm -qa|grep -i mariadb 卸载已安装的Mariabd 1rpm -qa|grep mariadb|xargs rpm -e --nodeps 确认是否卸载完成 1rpm -qa|grep -i mariadb 在MySQL官网中下载YUM源rpm安装包 1wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-8.noarch.rpm 安装mysql源 1yum localinstall mysql57-community-release-el7-8.noarch.rpm 检查mysql源是否安装成功 1yum repolist enabled | grep &quot;mysql.*-community.*&quot; 安装MySQL 1yum install mysql-community-server 检查mysql是否安装成功 1rpm -qa | grep mysql 启动 mysql 服务 1234systemctl start mysqld.service #启动 mysqlsystemctl restart mysqld.service #重启 mysqlsystemctl stop mysqld.service #停止 mysqlsystemctl enable mysqld.service #设置 mysql 开机启动 设置密码 为了加强安全性，MySQL5.7为root用户随机生成了一个密码，如果安装的是RPM包，则默认是在/var/log/mysqld.log中 获取随机生成的密码 1grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.log 123mysql -u root -p接着输入密码 用该密码登录到服务端后，必须马上修改密码，不然会报如下错误 123mysql&gt; select user();ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 如果只是修改为一个简单的密码，会报以下错误 123mysql&gt; ALTER USER USER() IDENTIFIED BY &#39;12345678&#39;;ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 这个其实与validate_password_policy的值有关。 validate_password_policy有以下取值： 123450 or LOW Length1 or MEDIUM Length; numeric, lowercase&#x2F;uppercase, and special characters2 or STRONG Length; numeric, lowercase&#x2F;uppercase, and special characters; dictionary file 默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。 修改validate_password_policy参数的值 123mysql&gt; set global validate_password_policy&#x3D;0;Query OK, 0 rows affected (0.00 sec) 这样，判断密码的标准就基于密码的长度了,最小为8 设置远程主机登录 1mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;your username&#39;@&#39;%&#39; IDENTIFIED BY &#39;your password&#39;; 为root 用户添加远程登录的能力 1mysql&gt; GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;your password&quot;; 这样就可以用navicate远程连接到数据库了 mongodb找一个文件夹存放安装包，我这里使用的是 /usr 123cd &#x2F;usrwget https:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;linux&#x2F;mongodb-linux-x86_64-4.0.0.tgz 解压缩安装包，并重命名文件夹 123tar zxvf mongodb-linux-x86_64-4.0.0.tgzmv mongodb-linux-x86_64-4.0.0 mongodb 配置环境变量 1vim &#x2F;etc&#x2F;profile 在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: 12#Set Mongodbexport PATH&#x3D;&#x2F;usr&#x2F;mongodb&#x2F;bin:$PATH 保存后通过下面的命令使环境变量生效： 123cd ~source &#x2F;etc&#x2F;profile 创建数据库目录 123456cd &#x2F;usr&#x2F;mongodbtouch mongodb.confmkdir dbmkdir logcd logtouch mongodb.log 修改mongodb配置文件 1vim &#x2F;usr&#x2F;mongodb&#x2F;mongodb.conf 添加以下内容 1234567891011port=27017 #端口dbpath= /usr/mongodb/db #数据库存文件存放目录logpath= /usr/mongodb/log/mongodb.log #日志文件存放路径logappend=true #使用追加的方式写日志fork=true #以守护进程的方式运行，创建服务器进程maxConns=100 #最大同时连接数noauth=true #不启用验证journal=true #每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）。#即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。storageEngine=wiredTiger #存储引擎有mmapv1、wiretiger、mongorocksbind_ip = 0.0.0.0 #这样就可外部访问了，例如从win10中去连虚拟机中的MongoDB 设置文件夹权限 12345cd &#x2F;usr&#x2F;mongodbchmod 777 dbchmod 777 log 启动mongodb 123cd ~mongod --config &#x2F;usr&#x2F;mongodb&#x2F;mongodb.conf","categories":[],"tags":[{"name":"部署","slug":"部署","permalink":"http://zhsblog.top/tags/%E9%83%A8%E7%BD%B2/"},{"name":"运维","slug":"运维","permalink":"http://zhsblog.top/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos","slug":"centos","permalink":"http://zhsblog.top/tags/centos/"}]},{"title":"Markdown常用语法","slug":"lean-markdown","date":"2019-12-19T08:24:32.000Z","updated":"2021-12-18T05:56:56.063Z","comments":true,"path":"2019/12/19/lean-markdown/","link":"","permalink":"http://zhsblog.top/2019/12/19/lean-markdown/","excerpt":"记录一些常用的markdown语法格式 1、标题123456789101112# 标题一级## 标题二级### 标题三级#### 标题四级或者我展示的是一级标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;我展示的是二级标题-----------------","text":"记录一些常用的markdown语法格式 1、标题123456789101112# 标题一级## 标题二级### 标题三级#### 标题四级或者我展示的是一级标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;我展示的是二级标题----------------- 2、字体12345678粗体：***加粗的字体***斜体：*倾斜的字体*或_倾斜的字体_ 被加粗的字体 倾斜的字体 3、分隔线下面每种写法都可以建立分隔线 123**** * *- - - 4、删除线、下划线123~~带删除线文本~~&lt;u&gt;带下划线文本&lt;&#x2F;u&gt; 带删除线文本 带下划线文本 5、脚注鼠标经过后显示脚注文本，类似于title 123创建脚注格式类似这样 [^footnote]。[^footnote]: footnote-content 生成一个脚注1^footnote. 6、区块引用1234567891011&gt;引用单行文字&gt; 带有多个段落的块引用&gt;&gt; 带有多个段落的块引用&gt; 嵌套引用1.&gt;&gt;&gt; 嵌套引用2. 引用文字的效果 引用多行文字1 引用多行文字2 嵌套引用1. 嵌套引用2. 7、段落123&gt;-段落1&gt;-段落2&gt;-段落3 段落1 段落2 段落3 8、列表Markdown 支持有序列表和无序列表。 无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记 12345* 第一项+ 第三项- 第三项 第一项 第三项 第三项 有序列表 1231. 第一项2. 第二项3. 第三项 第一项 第二项 第三项 9、列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可 1234561. 第一项 : - 第一项嵌套的的第一个 - 第一项嵌套的的第一个2. 第二项 - 第二项嵌套的第一个 - 第二项嵌套的第二个 第一项 : 第一项嵌套的的第一个 第一项嵌套的的第一个 第二项 第二项嵌套的第一个 第二项嵌套的第二个 10、列表中使用区块1234* 第一项 &gt; 区块内容1 &gt; 区块内容2* 第二项 第一项 区块内容1区块内容2区块内容2 第二项 11、代码区块片段代码可以用反引号 ` 包裹 printf() 函数 用 ``` 包裹一段代码，并指定一种语言（也可以不指定） javascript 123function scrolltoElement(elem, correction) &#123; correction = correction || scrollCorrection; &#125;; css 1display:flex; 12、超链接1234567[链接名称](链接地址)或者&lt;链接地址&gt;[我的博客](http:&#x2F;&#x2F;www.zhsblog.top)&lt;http:&#x2F;&#x2F;www.zhsblog.top&gt; 我的博客 13、 图片123456![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![一张头像图](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;zhouhuan327&#x2F;assets@1.2&#x2F;avatar&#x2F;cat.jpeg) 使用img标签引入的图片可以控制宽高&lt;img src=&quot;url&quot; width=&quot;50%&quot;&gt; 14、任务列表12345- [ ] 一次性水杯- [x] 西瓜- [ ] 豆浆- [x] 可口可乐- [ ] 小茗同学 一次性水杯 西瓜 豆浆 可口可乐 小茗同学 16、折叠面板12345&lt;details&gt;&lt;summary&gt;点击展开&lt;&#x2F;summary&gt;content!!!&lt;&#x2F;details&gt; 点击展开 content!!!","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://zhsblog.top/categories/Markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://zhsblog.top/tags/markdown/"}]}],"categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://zhsblog.top/categories/Markdown/"}],"tags":[{"name":"React","slug":"React","permalink":"http://zhsblog.top/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://zhsblog.top/tags/%E7%AC%94%E8%AE%B0/"},{"name":"electron","slug":"electron","permalink":"http://zhsblog.top/tags/electron/"},{"name":"部署","slug":"部署","permalink":"http://zhsblog.top/tags/%E9%83%A8%E7%BD%B2/"},{"name":"运维","slug":"运维","permalink":"http://zhsblog.top/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos","slug":"centos","permalink":"http://zhsblog.top/tags/centos/"},{"name":"markdown","slug":"markdown","permalink":"http://zhsblog.top/tags/markdown/"}]}